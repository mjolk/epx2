// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: epaxos.proto

/*
	Package epaxospb is a generated protocol buffer package.

	It is generated from these files:
		epaxos.proto

	It has these top-level messages:
		Command
		InstanceID
		InstanceData
		PreAccept
		PreAcceptOK
		PreAcceptReply
		Accept
		AcceptOK
		Commit
		Ballot
		Message
		InstanceState
		HardState
*/
package epaxospb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type InstanceState_Status int32

const (
	InstanceState_None        InstanceState_Status = 0
	InstanceState_PreAccepted InstanceState_Status = 1
	InstanceState_Accepted    InstanceState_Status = 2
	InstanceState_Committed   InstanceState_Status = 3
	InstanceState_Executed    InstanceState_Status = 4
)

var InstanceState_Status_name = map[int32]string{
	0: "None",
	1: "PreAccepted",
	2: "Accepted",
	3: "Committed",
	4: "Executed",
}
var InstanceState_Status_value = map[string]int32{
	"None":        0,
	"PreAccepted": 1,
	"Accepted":    2,
	"Committed":   3,
	"Executed":    4,
}

func (x InstanceState_Status) String() string {
	return proto.EnumName(InstanceState_Status_name, int32(x))
}
func (InstanceState_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorEpaxos, []int{11, 0}
}

type Command struct {
	Key     Key    `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Writing bool   `protobuf:"varint,3,opt,name=writing,proto3" json:"writing,omitempty"`
	Data    []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{0} }

func (m *Command) GetKey() Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Command) GetWriting() bool {
	if m != nil {
		return m.Writing
	}
	return false
}

func (m *Command) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type InstanceID struct {
	ReplicaID   ReplicaID   `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
	InstanceNum InstanceNum `protobuf:"varint,2,opt,name=instance_num,json=instanceNum,proto3,casttype=InstanceNum" json:"instance_num,omitempty"`
}

func (m *InstanceID) Reset()                    { *m = InstanceID{} }
func (m *InstanceID) String() string            { return proto.CompactTextString(m) }
func (*InstanceID) ProtoMessage()               {}
func (*InstanceID) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{1} }

func (m *InstanceID) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *InstanceID) GetInstanceNum() InstanceNum {
	if m != nil {
		return m.InstanceNum
	}
	return 0
}

type InstanceData struct {
	Command *Command     `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	SeqNum  SeqNum       `protobuf:"varint,2,opt,name=seq_num,json=seqNum,proto3,casttype=SeqNum" json:"seq_num,omitempty"`
	Deps    []InstanceID `protobuf:"bytes,3,rep,name=deps" json:"deps"`
}

func (m *InstanceData) Reset()                    { *m = InstanceData{} }
func (m *InstanceData) String() string            { return proto.CompactTextString(m) }
func (*InstanceData) ProtoMessage()               {}
func (*InstanceData) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{2} }

func (m *InstanceData) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *InstanceData) GetSeqNum() SeqNum {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *InstanceData) GetDeps() []InstanceID {
	if m != nil {
		return m.Deps
	}
	return nil
}

type PreAccept struct {
	InstanceData `protobuf:"bytes,1,opt,name=data,embedded=data" json:"data"`
}

func (m *PreAccept) Reset()                    { *m = PreAccept{} }
func (m *PreAccept) String() string            { return proto.CompactTextString(m) }
func (*PreAccept) ProtoMessage()               {}
func (*PreAccept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{3} }

// PreAcceptOK is used to respond to a PreAccept message is cases where the
// remote replica has no new information about the proposed command.
type PreAcceptOK struct {
}

func (m *PreAcceptOK) Reset()                    { *m = PreAcceptOK{} }
func (m *PreAcceptOK) String() string            { return proto.CompactTextString(m) }
func (*PreAcceptOK) ProtoMessage()               {}
func (*PreAcceptOK) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{4} }

// PreAcceptReply is used to respond to a PreAccept message in cases whe the
// remote replica has new information about the proposed command. This new
// information may either be a larger sequence number or extra dependencies.
type PreAcceptReply struct {
	UpdatedSeqNum SeqNum       `protobuf:"varint,1,opt,name=updated_seq_num,json=updatedSeqNum,proto3,casttype=SeqNum" json:"updated_seq_num,omitempty"`
	UpdatedDeps   []InstanceID `protobuf:"bytes,2,rep,name=updated_deps,json=updatedDeps" json:"updated_deps"`
}

func (m *PreAcceptReply) Reset()                    { *m = PreAcceptReply{} }
func (m *PreAcceptReply) String() string            { return proto.CompactTextString(m) }
func (*PreAcceptReply) ProtoMessage()               {}
func (*PreAcceptReply) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{5} }

func (m *PreAcceptReply) GetUpdatedSeqNum() SeqNum {
	if m != nil {
		return m.UpdatedSeqNum
	}
	return 0
}

func (m *PreAcceptReply) GetUpdatedDeps() []InstanceID {
	if m != nil {
		return m.UpdatedDeps
	}
	return nil
}

type Accept struct {
	InstanceData `protobuf:"bytes,1,opt,name=data,embedded=data" json:"data"`
}

func (m *Accept) Reset()                    { *m = Accept{} }
func (m *Accept) String() string            { return proto.CompactTextString(m) }
func (*Accept) ProtoMessage()               {}
func (*Accept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{6} }

type AcceptOK struct {
}

func (m *AcceptOK) Reset()                    { *m = AcceptOK{} }
func (m *AcceptOK) String() string            { return proto.CompactTextString(m) }
func (*AcceptOK) ProtoMessage()               {}
func (*AcceptOK) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{7} }

type Commit struct {
	InstanceData `protobuf:"bytes,1,opt,name=data,embedded=data" json:"data"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (m *Commit) String() string            { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{8} }

// Ballot is a ballot number that ensures message freshness.
type Ballot struct {
	Epoch     uint64    `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Number    uint64    `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	ReplicaID ReplicaID `protobuf:"varint,3,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
}

func (m *Ballot) Reset()                    { *m = Ballot{} }
func (m *Ballot) String() string            { return proto.CompactTextString(m) }
func (*Ballot) ProtoMessage()               {}
func (*Ballot) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{9} }

func (m *Ballot) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Ballot) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Ballot) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

type Message struct {
	// to is the destination of the message.
	To ReplicaID `protobuf:"varint,1,opt,name=to,proto3,casttype=ReplicaID" json:"to,omitempty"`
	// ballot is the message's ballot number.
	Ballot Ballot `protobuf:"bytes,2,opt,name=ballot" json:"ballot"`
	// instance_meta holds information of the message's corresponding instance.
	InstanceID InstanceID `protobuf:"bytes,3,opt,name=instance_id,json=instanceId" json:"instance_id"`
	// type is a union of different message types.
	//
	// Types that are valid to be assigned to Type:
	//	*Message_PreAccept
	//	*Message_PreAcceptOk
	//	*Message_PreAcceptReply
	//	*Message_Accept
	//	*Message_AcceptOk
	//	*Message_Commit
	Type isMessage_Type `protobuf_oneof:"type"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{10} }

type isMessage_Type interface {
	isMessage_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Message_PreAccept struct {
	PreAccept *PreAccept `protobuf:"bytes,4,opt,name=pre_accept,json=preAccept,oneof"`
}
type Message_PreAcceptOk struct {
	PreAcceptOk *PreAcceptOK `protobuf:"bytes,5,opt,name=pre_accept_ok,json=preAcceptOk,oneof"`
}
type Message_PreAcceptReply struct {
	PreAcceptReply *PreAcceptReply `protobuf:"bytes,6,opt,name=pre_accept_reply,json=preAcceptReply,oneof"`
}
type Message_Accept struct {
	Accept *Accept `protobuf:"bytes,7,opt,name=accept,oneof"`
}
type Message_AcceptOk struct {
	AcceptOk *AcceptOK `protobuf:"bytes,8,opt,name=accept_ok,json=acceptOk,oneof"`
}
type Message_Commit struct {
	Commit *Commit `protobuf:"bytes,9,opt,name=commit,oneof"`
}

func (*Message_PreAccept) isMessage_Type()      {}
func (*Message_PreAcceptOk) isMessage_Type()    {}
func (*Message_PreAcceptReply) isMessage_Type() {}
func (*Message_Accept) isMessage_Type()         {}
func (*Message_AcceptOk) isMessage_Type()       {}
func (*Message_Commit) isMessage_Type()         {}

func (m *Message) GetType() isMessage_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Message) GetTo() ReplicaID {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Message) GetBallot() Ballot {
	if m != nil {
		return m.Ballot
	}
	return Ballot{}
}

func (m *Message) GetInstanceID() InstanceID {
	if m != nil {
		return m.InstanceID
	}
	return InstanceID{}
}

func (m *Message) GetPreAccept() *PreAccept {
	if x, ok := m.GetType().(*Message_PreAccept); ok {
		return x.PreAccept
	}
	return nil
}

func (m *Message) GetPreAcceptOk() *PreAcceptOK {
	if x, ok := m.GetType().(*Message_PreAcceptOk); ok {
		return x.PreAcceptOk
	}
	return nil
}

func (m *Message) GetPreAcceptReply() *PreAcceptReply {
	if x, ok := m.GetType().(*Message_PreAcceptReply); ok {
		return x.PreAcceptReply
	}
	return nil
}

func (m *Message) GetAccept() *Accept {
	if x, ok := m.GetType().(*Message_Accept); ok {
		return x.Accept
	}
	return nil
}

func (m *Message) GetAcceptOk() *AcceptOK {
	if x, ok := m.GetType().(*Message_AcceptOk); ok {
		return x.AcceptOk
	}
	return nil
}

func (m *Message) GetCommit() *Commit {
	if x, ok := m.GetType().(*Message_Commit); ok {
		return x.Commit
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_PreAccept)(nil),
		(*Message_PreAcceptOk)(nil),
		(*Message_PreAcceptReply)(nil),
		(*Message_Accept)(nil),
		(*Message_AcceptOk)(nil),
		(*Message_Commit)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// type
	switch x := m.Type.(type) {
	case *Message_PreAccept:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PreAccept); err != nil {
			return err
		}
	case *Message_PreAcceptOk:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PreAcceptOk); err != nil {
			return err
		}
	case *Message_PreAcceptReply:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PreAcceptReply); err != nil {
			return err
		}
	case *Message_Accept:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Accept); err != nil {
			return err
		}
	case *Message_AcceptOk:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AcceptOk); err != nil {
			return err
		}
	case *Message_Commit:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Commit); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Type has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 4: // type.pre_accept
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PreAccept)
		err := b.DecodeMessage(msg)
		m.Type = &Message_PreAccept{msg}
		return true, err
	case 5: // type.pre_accept_ok
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PreAcceptOK)
		err := b.DecodeMessage(msg)
		m.Type = &Message_PreAcceptOk{msg}
		return true, err
	case 6: // type.pre_accept_reply
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PreAcceptReply)
		err := b.DecodeMessage(msg)
		m.Type = &Message_PreAcceptReply{msg}
		return true, err
	case 7: // type.accept
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Accept)
		err := b.DecodeMessage(msg)
		m.Type = &Message_Accept{msg}
		return true, err
	case 8: // type.accept_ok
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AcceptOK)
		err := b.DecodeMessage(msg)
		m.Type = &Message_AcceptOk{msg}
		return true, err
	case 9: // type.commit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Commit)
		err := b.DecodeMessage(msg)
		m.Type = &Message_Commit{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// type
	switch x := m.Type.(type) {
	case *Message_PreAccept:
		s := proto.Size(x.PreAccept)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_PreAcceptOk:
		s := proto.Size(x.PreAcceptOk)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_PreAcceptReply:
		s := proto.Size(x.PreAcceptReply)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Accept:
		s := proto.Size(x.Accept)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_AcceptOk:
		s := proto.Size(x.AcceptOk)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Commit:
		s := proto.Size(x.Commit)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type InstanceState struct {
	InstanceID   `protobuf:"bytes,1,opt,name=meta,embedded=meta" json:"meta"`
	Status       InstanceState_Status `protobuf:"varint,2,opt,name=status,proto3,enum=epaxospb.InstanceState_Status" json:"status,omitempty"`
	InstanceData `protobuf:"bytes,3,opt,name=data,embedded=data" json:"data"`
	Ballot       *Ballot `protobuf:"bytes,4,opt,name=ballot" json:"ballot,omitempty"`
}

func (m *InstanceState) Reset()                    { *m = InstanceState{} }
func (m *InstanceState) String() string            { return proto.CompactTextString(m) }
func (*InstanceState) ProtoMessage()               {}
func (*InstanceState) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{11} }

func (m *InstanceState) GetStatus() InstanceState_Status {
	if m != nil {
		return m.Status
	}
	return InstanceState_None
}

func (m *InstanceState) GetBallot() *Ballot {
	if m != nil {
		return m.Ballot
	}
	return nil
}

type HardState struct {
	// replica_id is the unique identifier for this node.
	ReplicaID ReplicaID `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
	// nodes is the set of all nodes in the EPaxos network.
	Nodes []ReplicaID `protobuf:"varint,2,rep,packed,name=nodes,casttype=ReplicaID" json:"nodes,omitempty"`
}

func (m *HardState) Reset()                    { *m = HardState{} }
func (m *HardState) String() string            { return proto.CompactTextString(m) }
func (*HardState) ProtoMessage()               {}
func (*HardState) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{12} }

func (m *HardState) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *HardState) GetNodes() []ReplicaID {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func init() {
	proto.RegisterType((*Command)(nil), "epaxospb.Command")
	proto.RegisterType((*InstanceID)(nil), "epaxospb.InstanceID")
	proto.RegisterType((*InstanceData)(nil), "epaxospb.InstanceData")
	proto.RegisterType((*PreAccept)(nil), "epaxospb.PreAccept")
	proto.RegisterType((*PreAcceptOK)(nil), "epaxospb.PreAcceptOK")
	proto.RegisterType((*PreAcceptReply)(nil), "epaxospb.PreAcceptReply")
	proto.RegisterType((*Accept)(nil), "epaxospb.Accept")
	proto.RegisterType((*AcceptOK)(nil), "epaxospb.AcceptOK")
	proto.RegisterType((*Commit)(nil), "epaxospb.Commit")
	proto.RegisterType((*Ballot)(nil), "epaxospb.Ballot")
	proto.RegisterType((*Message)(nil), "epaxospb.Message")
	proto.RegisterType((*InstanceState)(nil), "epaxospb.InstanceState")
	proto.RegisterType((*HardState)(nil), "epaxospb.HardState")
	proto.RegisterEnum("epaxospb.InstanceState_Status", InstanceState_Status_name, InstanceState_Status_value)
}
func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Writing {
		dAtA[i] = 0x18
		i++
		if m.Writing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *InstanceID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.ReplicaID))
	}
	if m.InstanceNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceNum))
	}
	return i, nil
}

func (m *InstanceData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Command != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Command.Size()))
		n1, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.SeqNum))
	}
	if len(m.Deps) > 0 {
		for _, msg := range m.Deps {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEpaxos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PreAccept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreAccept) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceData.Size()))
	n2, err := m.InstanceData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *PreAcceptOK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreAcceptOK) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PreAcceptReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreAcceptReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdatedSeqNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.UpdatedSeqNum))
	}
	if len(m.UpdatedDeps) > 0 {
		for _, msg := range m.UpdatedDeps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEpaxos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Accept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Accept) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceData.Size()))
	n3, err := m.InstanceData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *AcceptOK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptOK) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceData.Size()))
	n4, err := m.InstanceData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *Ballot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ballot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Epoch))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Number))
	}
	if m.ReplicaID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.ReplicaID))
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.To))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.Ballot.Size()))
	n5, err := m.Ballot.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceID.Size()))
	n6, err := m.InstanceID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.Type != nil {
		nn7, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *Message_PreAccept) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PreAccept != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.PreAccept.Size()))
		n8, err := m.PreAccept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Message_PreAcceptOk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PreAcceptOk != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.PreAcceptOk.Size()))
		n9, err := m.PreAcceptOk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Message_PreAcceptReply) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PreAcceptReply != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.PreAcceptReply.Size()))
		n10, err := m.PreAcceptReply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Message_Accept) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Accept != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Accept.Size()))
		n11, err := m.Accept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Message_AcceptOk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AcceptOk != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.AcceptOk.Size()))
		n12, err := m.AcceptOk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Message_Commit) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Commit != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Commit.Size()))
		n13, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *InstanceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceID.Size()))
	n14, err := m.InstanceID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceData.Size()))
	n15, err := m.InstanceData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.Ballot != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Ballot.Size()))
		n16, err := m.Ballot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *HardState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.ReplicaID))
	}
	if len(m.Nodes) > 0 {
		dAtA18 := make([]byte, len(m.Nodes)*10)
		var j17 int
		for _, num := range m.Nodes {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func encodeFixed64Epaxos(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Epaxos(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEpaxos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Command) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovEpaxos(uint64(l))
	}
	if m.Writing {
		n += 2
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}

func (m *InstanceID) Size() (n int) {
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovEpaxos(uint64(m.ReplicaID))
	}
	if m.InstanceNum != 0 {
		n += 1 + sovEpaxos(uint64(m.InstanceNum))
	}
	return n
}

func (m *InstanceData) Size() (n int) {
	var l int
	_ = l
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovEpaxos(uint64(m.SeqNum))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	return n
}

func (m *PreAccept) Size() (n int) {
	var l int
	_ = l
	l = m.InstanceData.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	return n
}

func (m *PreAcceptOK) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PreAcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.UpdatedSeqNum != 0 {
		n += 1 + sovEpaxos(uint64(m.UpdatedSeqNum))
	}
	if len(m.UpdatedDeps) > 0 {
		for _, e := range m.UpdatedDeps {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	return n
}

func (m *Accept) Size() (n int) {
	var l int
	_ = l
	l = m.InstanceData.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	return n
}

func (m *AcceptOK) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Commit) Size() (n int) {
	var l int
	_ = l
	l = m.InstanceData.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	return n
}

func (m *Ballot) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovEpaxos(uint64(m.Epoch))
	}
	if m.Number != 0 {
		n += 1 + sovEpaxos(uint64(m.Number))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovEpaxos(uint64(m.ReplicaID))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.To != 0 {
		n += 1 + sovEpaxos(uint64(m.To))
	}
	l = m.Ballot.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	l = m.InstanceID.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Message_PreAccept) Size() (n int) {
	var l int
	_ = l
	if m.PreAccept != nil {
		l = m.PreAccept.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_PreAcceptOk) Size() (n int) {
	var l int
	_ = l
	if m.PreAcceptOk != nil {
		l = m.PreAcceptOk.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_PreAcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.PreAcceptReply != nil {
		l = m.PreAcceptReply.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_Accept) Size() (n int) {
	var l int
	_ = l
	if m.Accept != nil {
		l = m.Accept.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_AcceptOk) Size() (n int) {
	var l int
	_ = l
	if m.AcceptOk != nil {
		l = m.AcceptOk.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_Commit) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *InstanceState) Size() (n int) {
	var l int
	_ = l
	l = m.InstanceID.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	if m.Status != 0 {
		n += 1 + sovEpaxos(uint64(m.Status))
	}
	l = m.InstanceData.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	if m.Ballot != nil {
		l = m.Ballot.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}

func (m *HardState) Size() (n int) {
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovEpaxos(uint64(m.ReplicaID))
	}
	if len(m.Nodes) > 0 {
		l = 0
		for _, e := range m.Nodes {
			l += sovEpaxos(uint64(e))
		}
		n += 1 + sovEpaxos(uint64(l)) + l
	}
	return n
}

func sovEpaxos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEpaxos(x uint64) (n int) {
	return sovEpaxos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Writing = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceNum", wireType)
			}
			m.InstanceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceNum |= (InstanceNum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (SeqNum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deps = append(m.Deps, InstanceID{})
			if err := m.Deps[len(m.Deps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAccept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAccept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAccept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptOK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptOK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptOK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedSeqNum", wireType)
			}
			m.UpdatedSeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedSeqNum |= (SeqNum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDeps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedDeps = append(m.UpdatedDeps, InstanceID{})
			if err := m.UpdatedDeps[len(m.UpdatedDeps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Accept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Accept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Accept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptOK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptOK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptOK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ballot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ballot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ballot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ballot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAccept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreAccept{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_PreAccept{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAcceptOk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreAcceptOK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_PreAcceptOk{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAcceptReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreAcceptReply{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_PreAcceptReply{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Accept{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_Accept{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptOk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AcceptOK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_AcceptOk{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_Commit{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (InstanceState_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ballot == nil {
				m.Ballot = &Ballot{}
			}
			if err := m.Ballot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v ReplicaID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEpaxos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (ReplicaID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nodes = append(m.Nodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEpaxos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEpaxos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v ReplicaID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEpaxos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (ReplicaID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nodes = append(m.Nodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEpaxos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEpaxos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEpaxos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEpaxos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEpaxos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEpaxos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("epaxos.proto", fileDescriptorEpaxos) }

var fileDescriptorEpaxos = []byte{
	// 793 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcd, 0x6e, 0xda, 0x4a,
	0x14, 0xc6, 0xd8, 0x31, 0xf8, 0x18, 0x12, 0xee, 0xdc, 0xdc, 0xc8, 0x37, 0xd2, 0xc5, 0x91, 0xb3,
	0x41, 0xb9, 0x2a, 0x51, 0xdd, 0xa8, 0x52, 0x5b, 0x35, 0x52, 0x28, 0x95, 0x40, 0x51, 0x93, 0xca,
	0xd9, 0x74, 0x87, 0x06, 0x7b, 0x4a, 0x2c, 0x82, 0xed, 0xe0, 0xb1, 0x1a, 0xd4, 0x65, 0x5f, 0x20,
	0xcb, 0x2e, 0xbb, 0xef, 0x8b, 0x64, 0x99, 0x27, 0x40, 0x15, 0x7d, 0x80, 0xee, 0x59, 0x55, 0x9e,
	0xb1, 0x0d, 0x01, 0xaa, 0x2a, 0xcd, 0x0a, 0x8e, 0xe7, 0xfb, 0xce, 0xcf, 0x37, 0xdf, 0xb1, 0xa1,
	0x44, 0x02, 0x7c, 0xe5, 0x87, 0xf5, 0x60, 0xe8, 0x53, 0x1f, 0x15, 0x79, 0x14, 0x74, 0xb7, 0x1f,
	0xf5, 0x5c, 0x7a, 0x1e, 0x75, 0xeb, 0xb6, 0x3f, 0xd8, 0xef, 0xf9, 0x3d, 0x7f, 0x9f, 0x01, 0xba,
	0xd1, 0x7b, 0x16, 0xb1, 0x80, 0xfd, 0xe3, 0x44, 0xe3, 0x1d, 0x14, 0x5e, 0xf9, 0x83, 0x01, 0xf6,
	0x1c, 0xf4, 0x2f, 0x88, 0x7d, 0x32, 0xd2, 0x84, 0x1d, 0xa1, 0x56, 0x6a, 0x14, 0xa6, 0x63, 0x5d,
	0x3c, 0x26, 0x23, 0x2b, 0x7e, 0x86, 0x34, 0x28, 0x7c, 0x18, 0xba, 0xd4, 0xf5, 0x7a, 0x9a, 0xb8,
	0x23, 0xd4, 0x8a, 0x56, 0x1a, 0x22, 0x04, 0x92, 0x83, 0x29, 0xd6, 0xa4, 0x98, 0x65, 0xb1, 0xff,
	0xcf, 0xa5, 0xcf, 0x5f, 0xf4, 0x9c, 0xf1, 0x11, 0xa0, 0xed, 0x85, 0x14, 0x7b, 0x36, 0x69, 0x37,
	0xd1, 0x33, 0x80, 0x21, 0x09, 0x2e, 0x5c, 0x1b, 0x77, 0x5c, 0x87, 0xd5, 0x90, 0x1a, 0xdb, 0x93,
	0xb1, 0xae, 0x58, 0xfc, 0x69, 0xbb, 0x39, 0x9d, 0x0f, 0x2c, 0x25, 0x41, 0xb7, 0x1d, 0x64, 0x42,
	0xc9, 0x4d, 0x12, 0x75, 0xbc, 0x68, 0xa0, 0xe5, 0x19, 0x79, 0x63, 0x3a, 0xd6, 0xd5, 0xb4, 0xc0,
	0x49, 0x34, 0xb0, 0x54, 0x77, 0x16, 0x18, 0xd7, 0x02, 0x94, 0xd2, 0xc3, 0x26, 0xa6, 0x18, 0xfd,
	0x0f, 0x05, 0x9b, 0xcf, 0xc9, 0x8a, 0xab, 0xe6, 0x5f, 0xf5, 0x54, 0xb2, 0x7a, 0x22, 0x80, 0x95,
	0x22, 0xd0, 0x2e, 0x14, 0x42, 0x72, 0x39, 0x57, 0x0c, 0xa6, 0x63, 0x5d, 0x3e, 0x23, 0x97, 0x71,
	0x1d, 0x39, 0x64, 0xbf, 0xa8, 0x0e, 0x92, 0x43, 0x82, 0x50, 0x13, 0x77, 0xc4, 0x9a, 0x6a, 0x6e,
	0xce, 0xd2, 0xcd, 0xa6, 0x6e, 0x48, 0x37, 0x63, 0x3d, 0x67, 0x31, 0x9c, 0x71, 0x04, 0xca, 0xdb,
	0x21, 0x39, 0xb2, 0x6d, 0x12, 0x50, 0x74, 0x90, 0xc8, 0xc6, 0x7b, 0xd9, 0x5a, 0x26, 0xc7, 0x4d,
	0x37, 0x8a, 0x31, 0xfd, 0x76, 0xac, 0x0b, 0x5c, 0x58, 0xa3, 0x0c, 0x6a, 0x96, 0xe2, 0xf4, 0xd8,
	0xf8, 0x24, 0xc0, 0x7a, 0x16, 0xc7, 0xd2, 0x8d, 0x90, 0x09, 0x1b, 0x51, 0xe0, 0x60, 0x4a, 0x9c,
	0x4e, 0x3a, 0x81, 0xb0, 0x34, 0x41, 0x39, 0x81, 0xf0, 0x10, 0xbd, 0x84, 0x52, 0xca, 0x61, 0x03,
	0xe5, 0x7f, 0x3b, 0x90, 0x9a, 0xe0, 0x9b, 0xf1, 0x5c, 0x87, 0x20, 0x3f, 0x68, 0x28, 0x80, 0x62,
	0x36, 0xd1, 0x21, 0xc8, 0xf1, 0x65, 0xb8, 0x7f, 0x9a, 0xeb, 0x12, 0xe4, 0x06, 0xbe, 0xb8, 0xf0,
	0x29, 0xda, 0x84, 0x35, 0x12, 0xf8, 0xf6, 0x39, 0x1f, 0xdf, 0xe2, 0x01, 0xda, 0x02, 0xd9, 0x8b,
	0x06, 0x5d, 0x32, 0xe4, 0xf7, 0x6a, 0x25, 0xd1, 0x82, 0x3b, 0xc5, 0x7b, 0xb8, 0xd3, 0xf8, 0x21,
	0x42, 0xe1, 0x0d, 0x09, 0x43, 0xdc, 0x23, 0xe8, 0x3f, 0xc8, 0x53, 0x3f, 0x11, 0xbc, 0x7c, 0x97,
	0x91, 0xa7, 0x3e, 0xaa, 0x83, 0xdc, 0x65, 0xdd, 0xb1, 0xea, 0xaa, 0x59, 0x99, 0x4d, 0xc5, 0xbb,
	0x4e, 0xe4, 0x4d, 0x50, 0xa8, 0x0d, 0x99, 0xa7, 0xd3, 0xb6, 0x7e, 0x75, 0x2f, 0x28, 0x26, 0x4e,
	0xc6, 0xfa, 0xdc, 0xca, 0x59, 0x90, 0x92, 0xdb, 0x0e, 0x3a, 0x00, 0x08, 0x86, 0xa4, 0x83, 0x99,
	0xd0, 0x6c, 0x59, 0x55, 0xf3, 0xef, 0x59, 0xa6, 0xcc, 0x45, 0xad, 0x9c, 0xa5, 0x04, 0x99, 0x4b,
	0x5f, 0x40, 0x79, 0xc6, 0xea, 0xf8, 0x7d, 0x6d, 0x8d, 0x11, 0xff, 0x59, 0x41, 0x3c, 0x3d, 0x6e,
	0xe5, 0x2c, 0x35, 0xa3, 0x9e, 0xf6, 0x51, 0x13, 0x2a, 0x73, 0xe4, 0x58, 0xb0, 0x91, 0x26, 0x33,
	0xbe, 0xb6, 0x82, 0xcf, 0xec, 0xdb, 0xca, 0x59, 0xeb, 0xc1, 0x5d, 0x43, 0xef, 0x81, 0x9c, 0x34,
	0x5d, 0x58, 0xd4, 0x2c, 0xeb, 0x38, 0x41, 0xa0, 0xc7, 0xa0, 0xcc, 0x5a, 0x2d, 0x32, 0x38, 0x5a,
	0x84, 0xb3, 0x3e, 0x8b, 0x38, 0x6d, 0x72, 0x0f, 0x64, 0x9b, 0x19, 0x4e, 0x53, 0x16, 0xd3, 0x73,
	0x23, 0xc6, 0xe9, 0x39, 0xa2, 0x21, 0x83, 0x44, 0x47, 0x01, 0x31, 0xbe, 0xe6, 0xa1, 0x9c, 0xca,
	0x7c, 0x46, 0x31, 0x25, 0xc8, 0x04, 0x69, 0x40, 0x32, 0xb3, 0xae, 0xbe, 0xa1, 0x39, 0xab, 0xc6,
	0x58, 0xf4, 0x14, 0xe4, 0x90, 0x62, 0x1a, 0x85, 0xcc, 0x0c, 0xeb, 0x66, 0x75, 0x99, 0xc5, 0x92,
	0xd7, 0xcf, 0x18, 0xca, 0x4a, 0xd0, 0xd9, 0x62, 0x88, 0xf7, 0x59, 0x0c, 0x54, 0xcb, 0xac, 0x27,
	0xad, 0xb6, 0x5e, 0x6a, 0x3a, 0xe3, 0x04, 0x64, 0x5e, 0x11, 0x15, 0x41, 0x3a, 0xf1, 0x3d, 0x52,
	0xc9, 0xa1, 0x8d, 0xb9, 0xf7, 0x0e, 0x71, 0x2a, 0x02, 0x2a, 0xa5, 0x3b, 0x4b, 0x9c, 0x4a, 0x1e,
	0x95, 0x41, 0xe1, 0x62, 0xc5, 0xa1, 0x18, 0x1f, 0xbe, 0xbe, 0x22, 0x76, 0x14, 0x47, 0x92, 0xd1,
	0x07, 0xa5, 0x85, 0x87, 0x0e, 0x17, 0xea, 0x01, 0x5f, 0x81, 0x5d, 0x58, 0xf3, 0x7c, 0x87, 0xf0,
	0xd7, 0xd3, 0xd2, 0x7a, 0xf1, 0xb3, 0x46, 0xe5, 0x66, 0x52, 0x15, 0x6e, 0x27, 0x55, 0xe1, 0xdb,
	0xa4, 0x2a, 0x5c, 0x7f, 0xaf, 0xe6, 0xba, 0x32, 0xfb, 0xcc, 0x3d, 0xf9, 0x19, 0x00, 0x00, 0xff,
	0xff, 0xc4, 0xfd, 0x0b, 0x42, 0x2f, 0x07, 0x00, 0x00,
}
